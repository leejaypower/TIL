# 오버플로우, 입력받는 함수

### 오버플로우(overflow)

<img alt="메모리 저장구역" src="../images/memory_layout.png">

- heap에서의 메모리 할당이 많아질 수록 사용하는 메모리의 범위는 아래로 늘어난다.

- stack 에서는 함수가 더 많이 호출될 수록 메모리의 범위가 위로 늘어난다.

- 이렇게 계속 늘어나게 되면 결국 메모리 자원은 한정되어 있기에 충돌하게 될 것이다.

- 이를 <b>heap overflow</b>, 또는 <b>stack overflow</b>라고 한다.

<br>

한편 CS50 라이브러리에 있는 함수들은 포인터를 사용해서
메모리 주소를 잘 관리한다.

라이브러리 함수들을 직접 구현해보겠다.

<br>

### get_int 함수 구현

```c
#include <stdio.h>

int main(void)
{
    int x;
    printf("x: ");
    scanf("%i", &x);
    // 사용자의 입력을 정수형식으로 x의 주소에 저장한다.
    printf("x: %i\n", x);
}
```

- <i>scanf</i> 함수는 명시한 형식 지정자대로 사용자의 입력을 받아 주소를 정해 저장한다.
- x의 주소(&x)를 scanf에 주는 이유는 남이 작성한 코드로 변수의 값을 바꾸고 싶을 때, 값으로 전달하면 복사본을 전달하기 때문이다.

<br>

### get_string 함수 구현

```c
#include <stdio.h>

int main(void)
{
    // char *s = NULL;
    // 여기서 NULL은 포인터로 가리키는 곳이 없다, 즉 메모리 공간이 할당되지 않았다는 뜻이다.
    char s[5];
    printf("s: ");
    scanf("%s", s);
    printf("s: %s\n", s);
}
```

- 주석 표기대로 char \*s로 문자의 배열(string)시작 주소를 선언하고,<br> NULL로 초깃값을 준다면, 사용자의 입력을 저장할 공간이 없게 된다.

- 배열은 메모리가 연속적으로 할당된 공간이고, 문자열은 문자가 연속적으로 있는 것이다.

- 문자열은 사실 그 메모리 공간 첫번째 주소를 의미한다.

- 따라서 이 문맥에서 포인터는 배열과 같다고 볼 수 있다.

- clang 컴파일러는 문자 배열의 이름을 포인터처럼 다룬다.

- scanf의 상황에서는 배열 첫 바이트 주소를 넘겨주는 것이다.

- char s[5]는 4개의 문자배열과 널종단 문자가 포함된 메모리 공간이다.

<br>

<br>
<hr>
<a href="https://www.boostcourse.org/cs112">모두를 위한 컴퓨터과학(CS50 2019)</a> - 파일쓰기로 공부한 내용입니다.
