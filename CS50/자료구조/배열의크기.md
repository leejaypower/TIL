# 자료구조 목차

1. [배열의 크기](#배열의-크기)
2. [연결 리스트](#연결리스트)
3. [해시 테이블, 트라이](#헤시-테이블,-트라이)
4. [스택, 큐, 딕셔너리](#스택,-큐,-딕셔너리)

<br>
<br>

# 배열의 크기

> 데이터 구조를 정의하고 관리하는 데 있어서 메모리와 포인터에 대한 개념을 정확히 이해하는 것이 중요하다.

### malloc과 포인터 예제

```c
int main(void)
{
    int *x;
    int *y;

    x = malloc(sizeof(int));

    *x = 42;
    *y = 13;
}
```

- 여기서 y는 포인터로만 선언되었다.
- y가 초기화되지 않았기 때문에 쓰레기값을 가진다.
- y는 원하지 않는 메모리 어딘가를 임의로 가리키고 있기 때문에 값을 저장할 때 오류가 발생할 수 있다.

<br>

### 이미 정의된 배열의 크기를 조정하기

- 배열의 크기는 미리 지정해야 한다.
- 배열의 크기가 일정하게 할당되어 있는 상태에서 단순히 크기를 늘릴 수 없다.
- 그 배열의 주변 메모리들은 이미 다른 목적으로 사용되고 있을 수 있기 때문이다.

<br>

이미 정의된 배열의 크기를 늘리려면 어떻게 해야될까?

<br>

새로운 공간에 메모리 크기를 다시 할당해서 기존 배열을 옮기는 방법: O(n)

```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
  //int 자료형 3개로 이루어진 list 라는 포인터를 선언하고 메모리 할당
  int *list = malloc(3 * sizeof(int));

  // 포인터가 잘 선언되었는지 확인
  if (list == NULL)
  {
      return 1;
  }

  // list 배열의 각 인덱스에 값 저장
  list[0] = 1;
  list[1] = 2;
  list[2] = 3;

  //int 자료형 4개 크기의 tmp 라는 포인터를 선언하고 메모리 할당
  int *tmp = malloc(4 * sizeof(int));

  if (tmp == NULL)
  {
      return 1;
  }

  // list의 값을 tmp로 복사
  for (int i = 0; i < 3; i++)
  {
      tmp[i] = list[i];
  }

  // tmp배열의 네 번째 값도 저장
  tmp[3] = 4;

  // list의 메모리를 초기화
  free(list);

  // list가 tmp와 같은 곳을 가리키도록 지정
  list = tmp;

  // 새로운 배열 list의 값 확인
  for (int i = 0; i < 4; i++)
  {
      printf("%i\n", list[i]);
  }

  // list의 메모리 초기화
  free(list);
}

```

- 배열의 크기만큼 많은 연산이 필요하고 실행시간이 오래걸린다.
- 이 예제는 시범을 위한 것으로, 만약 배열의 크기를 다시 지정하고 싶다면 이전 코드를 다시 짜면 된다.

<br>

위 과정을 좀 더 간단히 만들 수 있다.<br>
malloc대신 realloc을 사용해서 메모리를 새로 할당한다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int *list = malloc(3 * sizeof(int));
    if (list == NULL)
    {
        return 1;
    }

    list[0] = 1;
    list[1] = 2;
    list[2] = 3;

    // tmp 포인터에 메모리를 할당하고 list의 값 복사
    int *tmp = realloc(list, 4 * sizeof(int));
    if (tmp == NULL)
    {
        return 1;
    }

    // list가 tmp와 같은 곳을 가리키도록 지정
    list = tmp;

    // 새로운 list의 네 번째 값 저장
    list[3] = 4;

    // list의 값 확인
    for (int i = 0; i < 4; i++)
    {
        printf("%i\n", list[i]);
    }

    //list 의 메모리 초기화
    free(list);
}
```

- realloc 함수는 이미 할당받은 기존 메모리를 새롭게 가져온다.
- 배열의 크기와 상관없이 새롭게 설정된 크기로 바꾸며
- 기존 배열에서 새로운 배열로 데이터를 복사해준다.

이처럼 이미 할당된 메모리의 크기를 조절하기 위해서는
임시 메모리를 새로 할당해야한다.<br>
데이터를 덮어씌우는 과정에서 기존의 데이터를 손실하는 문제를 방지하기 위함이다.

<br>

> 배열은 본질적으로 메모리의 덩어리이다.

따라서 malloc과 배열은 같은 것이지만,
배열은 컴파일러를 통해서 자동으로 메모리를 <i>free</i> 해주는 기능을 가진다.

<br>
<br>

# 연결리스트

```
struct(구조체)
.
*
```

- struct: 이름과 번호가 들어있는 person 구조체와 같이 속성을 지정한 나만의 자료구조
- . : 구조체의 속성값 가져올 때 사용
- \* : 메모리 덩어리로 접근할 수 있는 역참조 연산자

<br>

배열의 장점

- 대괄호를 이용해서 문법적으로 쉽게 인덱싱이 가능하다.
- 일정한 시간에 접근할 수 있다. 즉, <i>랜덤 접근</i> 이 가능하다.

<br>

### 연결리스트

<img alt="" src="../images/linked_list_with_addresses.png">

> <b>연결 리스트</b>는 메모리 덩어리 여러 개를 포함한 데이터 구조이다. 이 메모리들은 포인터로 연결되어 있다.

- 이 구조는 배열이 아니다. 1, 2, 3이 서로 인접해있지 않기 때문이다.

- 값들이 서로 붙어있지 않기 때문에 여기서는 대괄호를 사용할 수 없다.
- 1, 2, 3을 담아 리스트들을 정렬된 상태로 유지하기 위해 값을 저장한 메모리에 여유 공간을 추가해 일종의 <b>주소 역할</b>을 하게 한다.
- 메모리 덩어리는 그 다음 정렬할 메모리를 가리킨다.
- 리스트의 마지막 메모리 덩어리는 <b>NULL</b>을 가리켜 이 리스트에 더이상 남은 것이 없다고 나타낸다.
- NULL은 포인터이고 그 값은 0이다.

<br>

### 연결리스트의 구조체 정의

```c
typedef struct node
{
    int number;
    struct node *next;
}
node;
```

> 컴퓨터 공학에서 node의 의미는 직사각형으로 나타낼 수 있는 메모리 덩어리를 의미한다. 그리고 이를 여러 목적에 의해 사용할 수 있다.

- 이 연결리스트는 두 개의 필드를 갖고 있다.

- 하나는 정수타입으로 이름을 number라고 부르도록 하겠다.

- 또 다른 필드는 리스트의 다음 요소를 가리키는 메모리 덩어리로, 관례적으로 next라고 부른다.

- node 구조체가 정의되지 않은 시점에서 next node를 가리켜야하기 때문에 <i>typedef struct</i> 뒤에 <i>node</i>를 붙인다.

<br>

### 연결리스트의 구현

```c
#include <stdio.h>
#include <stdlib.h>

//연결 리스트의 기본 단위가 되는 node 구조체 정의
typedef struct node
{
    //node 안에서 정수형 값이 저장되는 변수 name
    int number;

    //다음 node의 주소를 가리키는 포인터 *next
    struct node *next;
}
node;

int main(void)
{

    // 연결 리스트의 가장 첫 번째 node를 가리킬 node 포인터 list
    // list를 NULL로 초기화. 현재 아무것도 가리키지 않음.
    node *list = NULL;

    // 새로운 node를 위해 메모리를 할당하고 포인터 n으로 가리킨다.
    node *n = malloc(sizeof(node));
    if (n == NULL)
    {
        return 1;
    }

    // n이 가리키는 node의 number 필드(속성)
    // (*n).number
    n->number = 1;

    // n 다음에 정의된 node가 없으므로 NULL로 초기화
    n->next = NULL;

    // 첫번째 node를 정의했기 떄문에 list 포인터를 n 포인터로 바꿔준다.
    list = n;

    // list에 node를 더 연결하기 위해 n에 새로운 메모리를 다시 할당
    n = malloc(sizeof(node));
    if (n == NULL)
    {
        return 1;
    }

    // n의 number와 next의 값을 각각 저장
    n->number = 2;
    n->next = NULL;

    // list가 가리키는 것은 첫 번째 node이다. 이 다음 node를 n 포인터로 지정한다.
    list->next = n;

    // 다시 한 번 n 포인터에 새로운 메모리를 할당하고 number과 next의 값을 저장
    n = malloc(sizeof(node));
    if (n == NULL)
    {
        return 1;
    }

    n->number = 3;
    n->next = NULL;

    // 현재 list는 첫번째 node를 가리키고, 이는 두번째 node와 연결되어 있다.
    // 따라서 세 번째 node를 더 연결하기 위해 첫 번째 node (list)의
    // 다음 node의 다음 node(list->next->next)를 n 포인터로 지정
    list->next->next = n;

    // 이제 list에 연결된 node를 처음부터 방문하면서 각 number 값을 출력
    // 마지막 node의 next에는 NULL이 저장되어 있고 이 것은 for 루프의 종료 조건이 된다.
    for (node *tmp = list; tmp != NULL; tmp = tmp->next)
    {
        printf("%i\n", tmp->number);
    }

    // list에 연결된 node들을 처음부터 방문하면서 메모리를 해제
    while (list != NULL)
    {
        node *tmp = list->next;
        free(list);
        list = tmp;
    }
}

```

- malloc을 사용해 메모리를 할당할 때는 항상 반환된 값을 체크해서 검사해야한다.

<br>

### 배열과 연결리스트

- 연결 리스트를 사용하면
  실제로 데이터가 연속되어있지 않아도 <b>연속된 데이터처럼 사용</b>할 수 있다.
- 연결 리스트는 배열처럼 연속된 빈 메모리 공간이 필요하지 않다.<br>
- 연결 리스트는 새로운 데이터를 리스트 중간에 삽입해야할 때도, 포인터만 바꾸면 되기 때문에 전체를 수정할 필요도 없다.
- 하지만 연결리스트는 정적구조인 배열과 다르게 임의 접근이 불가능하다.
- 연결 리스트에 특정 값을 검색하려면 그 값이 있는 위치까지 리스트의 node를 거쳐 이동해야 한다.
- 따라서 연결 리스트의 크기가 n일때 그 실행시간은 O(n)이 된다.

<br>

### 연결리스트 : 트리

> 트리는 연결리스트를 기반으로 한 새로운 데이터 구조이다.

포인터 개념을 이용해서 더 많은 공간을 할당하고 자료 구조들을 이어 붙여서 개념상 2차원으로 만든다.

<br>

이진 탐색 트리<br>
<img alt="이진 검색 트리" src="../images/binary_search_tree.png">

```c
//이진 검색 트리의 노드 구조체
typedef struct node
{
  // 노드의 값
  int number;

  // 왼쪽 자식 노드
    struct node *left;

  // 오른쪽 자식 노드
    struct node *right;
} node;
```

- 포인터를 이용했기 때문에 연결리스트처럼 역동성을 가진다.
- 트리가 시작되는 가장 높은 층의 노드를 <b>루트</b>라고 한다.
- 트리의 높이는 로그를 따른다.

<br>

50을 재귀적으로 검색하는 이진 검색 함수

```c
// 이진 검색 함수 (*tree는 이진 검색 트리를 가리키는 포인터)
bool search(node *tree)
{
    // 트리가 비어있는 경우 ‘false’를 반환하고 함수 종료
    if (tree == NULL)
    {
        return false;
    }
    // 현재 노드의 값이 50보다 크면 왼쪽 노드 검색
    else if (50 < tree->number)
    {
        return search(tree->left);
    }
    // 현재 노드의 값이 50보다 작으면 오른쪽 노드 검색
    else if (50 > tree->number)
    {
        return search(tree->right);
    }
    // 위 모든 조건이 만족하지 않으면 노드의 값이 50이므로 ‘true’ 반환
    else {
        return true;
    }
}

```

- 이진 검색 트리를 사용해서 검색하면 실행시간, 노드 삽입 시간은 O(log n)이다.
- 이진 탐색이 가능한 배열과 같은 실행시간이다.
- 연결리스트는 크기를 줄이거나 늘릴 수 있지만 이진탐색은 불가능하다.
- 하지만 메모리를 더 사용해서 노드에 포인터를 두 개씩 넣으면 탐색하는 시간을 log로 단축시킬 수 있다.

<br>
<br>

# 해시 테이블, 트라이

## 해시 테이블

일정한 실행 시간을 가지도록 해주는 자료 구조로 <b>해시 테이블</b>이 있다.

해시 테이블은 배열과 연결 리스트를 조합한 것으로, <b>연결리스트의 배열</b> 이라고 말할 수 있다.

> 해시 테이블에서는 단어나 이름같은 입력값이 들어온다면 그 단어에 포함된 문자를 보고 어디에 그 이름을 넣을지 결정하는 방식이 흔히 사용된다.

<br>

여러개의 값들은 <b>해시 함수</b>를 통해 여러 연결리스트에 나눠 담아진다. 그리고 이러한 여러개의 연결리스트의 집합이 해시테이블이다.

<br>

### 해시 테이블 예제

예를 들어, 사람들의 이름을 자료로 담기 위해 이름의 첫 글자별로 나눠 저장하려고 한다.<br> 알파벳을 이용해 세로로 배열을 만들고, 중복되는 첫글자 값을 넣기 위해 가로로 연결 리스트를 만든다.<br>
이 때 해시 함수는 <i>이름의 가장 첫 글자</i> 이고, 최종적으로 저장되는 자료구조는 <i>해시 테이블</i> 이다.

<img alt="해시테이블 예제" src="../images/hash_table.png">

- 인덱싱을 하는데 사용하는 배열이 해시 함수이다.
- 해시 함수는 어떤 함수이자, 과정이자, 알고리즘이다.
- 이상적인 해시 함수의 검색 시간은 O(1)이 된다.
- 하지만 단 하나의 배열칸에 모든 값들이 연결리스트로 이어져서 O(n)이 될 수도 있다.
- 일반적으로는 배열의 칸을 여러개로 나누기 때문에 O(1)에 가깝다.

<br>

배열 칸을 여러개로 나눌수록 검색 시간은 빨라지지만 그만큼 메모리가 많이 사용된다.<br>
따라서 시간과 공간의 균형을 찾는 것이 중요하다.<br>
이상적인 해시함수를 만들기 위해서는 일정한 기준을 통해 데이터가 최대한 고루 분배될 수 있게 하는 것이다.

<br>

## 트라이

trie는 retrieval(검색)에서 파생된 단어이다.

> 트라이는 기본적으로 <b>트리 형태</b>의 자료구조이다. 특이한 점은 각 노드가 <b>배열</b>로 이루어져 있다는 것이다.

- 트라이는 어떤 자원을 절약하기 위해 다른 자원을 소비하는 패턴을 가진다.

- 트라이에는 많은 메모리가 들지만, 자료구조 안에 있는 이름이나 단어를 찾는데 일정한 실행 시간을 갖는다.

<br>

### 영어로 이루어진 문자열을 저장하는 예제

<img alt="트라이 예제" src="../images/trie.png">

- 노드는 a-z까지의 배열이 된다.
- 루트 노드에서 해당되는 첫 글자로 시작된다.
- 배열의 각 요소, 즉 알파벳은 다음 층의 노드(a~z)를 가리킨다.
- C 언어에서는 마지막 글자에서 불리언 연산자로 문자열이 끝난다는 것을 표기할 수 있다.
- 이 예제에서는 저장된 여러 개의 문자열이 최소 하나의 노드를 나누어 가지고 있다.
- 접두어가 같은 경우 어느 정도 효율이 있다.
- 트라이에서의 검색은 문자열의 모든 글자를 본다. 따라서 검색 시간은 문자열의 길이에 의해 한정된다.
- 따라서 실행 시간은 O(n)이다.
- 하지만 이름은 고정된 값(상수)이기 때문에 <b>O(1)</b>이라고 볼 수 있다.
- 하나의 문자열을 찾기 위해 그 문자열의 문자만 본다.
- 실행시간이 일정한 대신 메모리가 많이 필요한 것을 예제를 통해 확인할 수 있다.

<br>
<br>

# 스택, 큐, 딕셔너리

### 큐(queue)

선입선출의 특징을 가진 자료구조

> 큐는 사람들이 앞으로 줄을 선 것이며, 선입 선출(FIFO)이 유지되도록 하는 것이다.

큐에는 두 가지 기본 연산이 있다.

```
enqueue : 줄을 서는 것
dequeue : 줄을 빠져 나오는 것
```

큐의 개념을 구현하기 위해서는 배열이나 연결리스트가
필요하다.

<br>

### 스택(stack)

스택은 값이 위로 쌓이는 구조라서, 후입 선출 방식이다.<br>
다양한 맥락에서 나쁜 속성일 수도 있지만 항상 그렇지는 않다.<br>
스택도 배열이나 연결 리스트를 통해 구현 가능하다.

```
push : 요소 추가 - 요소를 밀어 넣는다.
pop : 요소 제거 - 가장 위의 요소를 뺀다.
```

<br>

### 딕셔너리(dictionary)

딕셔너리는 해시 테이블이라고도 생각할 수 있는 개념이다.<br>
일반적으로 컴퓨터 공학에서 딕셔너리는 키와 값의 쌍으로 이루어진다.

<br>
<hr>
<a href="https://www.boostcourse.org/cs112">모두를 위한 컴퓨터과학(CS50 2019)</a> - 자료구조로 공부한 내용입니다.
