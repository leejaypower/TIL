# 알고리즘 목차

1. [알고리즘 표기법](#알고리즘-표기법)
2. [선형검색](#선형검색)
3. [버블정렬](#버블정렬)
4. [선택정렬](#선택정렬)
5. [재귀](#재귀)
6. [병합정렬](#병합정렬)

<br>
<br>

# 알고리즘 표기법

사람들은 한눈에 배열 안에 들어있는 내용물을 전반적으로 파악할 수 있지만, 컴퓨터는 그럴 수 없다.<br>
컴퓨터에게는 빠르게 전체를 훑어서 파악하는 능력이 없다.<br>
컴퓨터는 배열 속 내용물을 하나하나씩 봐야한다.<br>
이것은 <b>알고리즘</b>과 비슷하다.

예를 들어 <b>선형 검색</b>은 시작부터 끝까지 차례대로 검색하는 방법이다.<br>
<b>이진 검색</b>은 문제를 두갈래로 나눠서 해결할때까지 반복 검색한다.<br>
분할과 정복 기법또한 이진검색이라 할 수 있다.<br>
그리고 끝까지 검색했을 때 원하는 결과가 나오지 않으면 <b>false</b>를 반환한다.

<br>

### Big O 표기법

<img alt="big O 표기법" src="../images/running_time.png">

- 알고리즘은 직선으로 그려지는 선형의 형태이거나
- 좀 더 굴곡이 있거나 로그 형태일 수도 있다.
- 배열의 아이템을 n으로 나타내었다.
- 각각 다른 이 모양은 알고리즘이 <i>최악의 경우 필요한 계산 수</i> 를 나타낸다.
- 즉, Big-O는 <b>알고리즘을 수행하는데 필요한 시간의 상한선</b>을 의미한다.

<br>

컴퓨터 과학자들은 알고리즘을 설명하기 위해 특정 용어를 사용한다.<br>
알고리즘이 얼마나 잘 설계되어 있는지, 또 코드가 얼마나 잘 구현되어있는지 말해준다.<br>

가장 일반적으로 <b>Big-O 표기법</b>을 사용한다.<br>
이름 그대로 대문자 O로 나타내는데, <i>" on the order of "</i> 의 약자이다.

> 쉽게 생각하면 "~만큼의 정도로 커지는" 것이라고 볼 수 있다.

누군가 당신의 알고리즘이 얼마나 효율적인지 물어본다면,<br> 즉 코드의 효율성을 묻는다면 은유적이면서도 직관적으로 코드의 속도를 대략 알려줄 수 있다.

<br>

세상에는 다양한 알고리즘이 있는데, 가장 대표적인 실행 시간(프로그램이나 알고리즘이 동작하는데 걸리는 시간)은 이렇다.

- O(n) : O(n)나 O(n/2)는 n만큼 커지므로 n이 늘어날 수록 선형적으로 커지게 된다. - 선형검색
- O(n²) : 버블정렬, 선택정렬
- O(n log n) : 병합정렬
- O(n)
- O(log n): 이진검색
- O(1)

<br>

### Big Ω(Omega) 표기법

<b>알고리즘 수행시간의 하한선</b>을 의미한다. 즉 필요한 계산 수의 최선의 경우이다.

- Ω(n²) : 버블 정렬, 선택정렬
- Ω(n log n) : 병합 정렬
- Ω(n): 최적화된 버블 정렬
- Ω(log n)
- Ω(1) : 한번에 찾는 경우 - 선형검색, 이진검색

<br>

<b>알고리즘의 수행시간의 상한선이 낮은 것이 하한선이 낮은 것보다 좋다.</b><br>
최악의 경우에 프로그램이 어떻게 동작할지, 또는 평균적으로 어떻게 동작하는지를 생각해야 하기 때문이다.

<br>
<br>

# 선형 검색

<b>선형 검색</b>은 원하는 결과가 나올 때 까지 처음부터 끝까지 차례대로 검색한다. <br>
최악의 경우 모든 모든 원소를 확인해야 하므로 비효율적이다.<br>
따라서 <b>선형 검색은 자료가 정렬되어 있지 않거나, 어떤 정보도 없을 경우에 사용하는 것이 좋다.</b>

<br>

주어진 배열에서 특정 값을 찾기 위한 선형검색 예제

```c
#include <cs50.h>
#include <stdio.h>
int main(void)
{
    // numbers 배열 정의 및 값 입력
    int numbers[] = {4, 8, 15, 16, 23, 42};
    // 값 50 검색
    for (int i = 0; i < 6; i++)
    {
        if (numbers[i] == 50)
        {
            printf("Found\n");
            return 0;
        }
    }
    printf("Not found\n");
    return 1;
}
```

<br>

문자열로 이루어진 배열에서 선형 검색 예제

```c
#include <cs50.h>
#include <stdio.h>
#include <string.h>
int main(void)
{
    string names[] = {"EMMA", "RODRIGO", "BRIAN", "DAVID"};
    string numbers[] = {"617–555–0100", "617–555–0101", "617–555–0102", "617–555–0103"};
    for (int i = 0; i < 4; i++)
    {
        if (strcmp(names[i], "EMMA") == 0)
        {
            printf("Found %s\n", numbers[i]);
            return 0;
            // 검색성공시 0을 반환하고 끝낸다.
        }
    }
    printf("Not found\n");
    return 1;
    // 검색실패시 1을 반환
}
```

- C언어는 문자열을 비교하기 위해 등호를 사용할 수 없다.
- <i>strcmp</i>는 string.h의 문자열을 비교하는 함수이다.
- 하지만 이 예제는 names와 numbers가 올바른 순서로 나열되어 있어야만 올바른 값이 나온다.

<br>

위 예제를 보완하기 위해 사람의 이름과 번호를 같이 저장해보자.

```c
#include <cs50.h>
#include <stdio.h>
#include <string.h>
typedef struct
// 여러가지 자료형을 위한 그릇
{
    string name;
    string number;
}
person;
int main(void)
{
    person people[4];
    people[0].name = "EMMA";
    people[0].number = "617–555–0100";
    people[1].name = "RODRIGO";
    people[1].number = "617–555–0101";
    people[2].name = "BRIAN";
    people[2].number = "617–555–0102";
    people[3].name = "DAVID";
    people[3].number = "617–555–0103";
    // EMMA 검색
    for (int i = 0; i < 4; i++)
    {
        if (strcmp(people[i].name, "EMMA") == 0)
        {
            printf("Found %s\n", people[i].number);
            return 0;
        }
    }
    printf("Not found\n");
    return 1;
}
```

- person이라는 <b>구조체(struct)</b>를 만든다.
- person이라는 자료형이 생성된다.
- 이렇게 캡슐화를 하여 관련 정보를 한번에 관리할 수 있다.

<br>
<br>

# 버블정렬

배열을 검색할 때, 정렬되지 않은 경우 선형검색처럼 시간이 더 오래걸리고 비효율적인 알고리즘을 사용해야 한다.

상황에 따라 배열에 대해 여러번 탐색을 해야하는 경우라면 먼저 <b>정렬</b>해두는 것이 효율적이다.

<br>

정렬 알고리즘 중 <b>버블정렬</b>이 있다.<br>
새로운 거품이 떠오르듯 왼쪽에서 오른쪽으로 이동하는 방식이라 버블이라는 이름이 붙었다.

> 버블 정렬은 <b>두 개의 인접한 자료 값을 비교하면서 위치를 교환하는 방식</b>으로 정렬하는 방법을 말한다.<br>
> 버블 정렬은 단 두 개의 요소만 정렬해주는 좁은 범위의 정렬에 집중한다.<br>
> 이 접근법은 간단하지만 단 하나의 요소를 정렬하기 위해 <b>너무 많이 교환하는 낭비</b>가 발생할 수도 있다.

```
(6 3) 8 5 2 7 4 1 - 교환
3 (6 8) 5 2 7 4 1 - 그대로 둠
3 6 (8 5) 2 7 4 1 - 교환
3 6 5 (8 2) 7 4 1 - 교환
...
3 6 5 2 8 4 1 7
...
오름차순이 될 때까지 반복
...
1 2 4 3 5 6 7 8
```

<br>

### 버블 정렬의 의사코드

```
n-1번 반복한다.(n명이 있고 서로를 비교한다면 최대 n-1번을 비교할 수 있다.)
  i가 0부터 n-2까지 (여기서 i는 배열의 인덱스) 반복한다.
    i가 0부터 시작할 때, i번째 사람과 i+1번째 사람의 순서가 잘못됐다면 자리를 바꾼다.
```

<br>

### 버블 정렬의 Big-O 표기

```
(n-1) X (n-1)
n² - 1n - 1n + 1
n² - 2n + 1
O(n²)
```

- 바깥 반복문과 안쪽 반복문이 n-1번 반복된다.
- 지수가 가장 큰 n²의 영향력이 가장 크다.
- n이 커질수록 n²가 미치는 영향은 더 커진다.
- 따라서 버블 정렬의 Big-O 표기는 O(n²)이다.
- <b>버블 정렬은 선형 탐색이나 이진 탐색보다 더 시간이 많이 든다.</b>

<small> <i> cs50 강의에서는 비교횟수가 (n-1)(n-1)라고 했지만 버블정렬 공식을 찾아보니 n(n-1)/2 이다. cs50에서 이렇게 설명한 이유가 뭘까..? </i> </small>

<br>

### 버블 정렬의 Big Ω 표기

이미 정렬 되어있는 상태에서도, <br>
버블 정렬은 맹목적으로 여전히 같은 횟수를 반복하게 된다.<br>
따라서 버블 정렬의 하한선도 <b>n²</b>가 된다.

<br>

### 실행시간의 단축

의사코드를 교환이 없을때까지만 반복하도록 바꾸면 이미 정렬이 되어있는 경우 실행 시간을 단축할 수 있다.

```
교환이 일어나지 않을때까지만 반복한다.
  i가 0부터 n-2까지 (여기서 i는 배열의 인덱스) 반복한다.
    i가 0부터 시작할 때, i번째 사람과 i+1번째 사람의 순서가 잘못됐다면 자리를 바꾼다.
```

이 경우 n-1번 반복하므로, <b>버블 정렬의 하한은 Ω(n)이 된다.</b><br>
따라서 버블 정렬은 상황에 따라서 선택 정렬보다 더 빠른 방법이 될 수 있다.

<br>
<br>

# 선택정렬

<b>선택 정렬</b>의 방법은 다음과 같다.

```
6 3 8 5 2 7 4 (1)
```

- 배열의 원자들을 차례대로 확인하고 배열 중 가장 작은 값을 찾는다.

<br>

```
(1) 3 8 5 2 7 4 (6)
```

- 배열의 첫번째 자리에 가장 작은 값을 둔다.

- 원래 있었던 첫번째 값은 가장 작은 값이 있었던 자리로 위치를 교환한다.

<br>

```
1 3 8 5 (2) 7 4 6
1 (2) 8 5 (3) 7 4 6
...
```

- 오름차순 정렬을 위해 가장 작은 값을 먼저 찾고, 그 다음으로 작은 값을 찾고를 반복한다.<br>
  <br>

### 선택정렬의 의사코드

n개의 아이템이 있다면, 첫번째 아이템은 0번째, 마지막 아이템은 n-1번째이다.

```
i가 0부터 n-1까지 반복한다.
  i번째 부터 마지막 아이템까지 가장 작은 아이템을 찾는다.
  그 항목을 i번째 항목과 교환한다.
```

<br>

### 선택정렬의 Big-O 표기

가장 작은 항목을 찾기 위해서는 모든 항목, 즉 n번의 과정이 필요하다.<br>
그 다음 작은 항목을 찾기 위해서는 n-1번의 과정이 필요하다.<br>
그렇게 오름차순까지 반복해서 n-2, n-3, n-4...번의 과정을 거친다.<br>

```
n + (n-1) + (n-2) + ... + 1
n(n+1)/2
(n²+n)/2
n²/2 + n/2
O(n²)
```

- 선택 정렬의 Big-O는 <b>O(n²)</b>이다.

<br>

### 선택 정렬의 Big Ω 표기

1부터 8까지 이미 오름차순 정렬이 되어있더라도, <br>
컴퓨터는 모든 배열을 확인하기 전까지는 1이 가장 작은 숫자라는 것을 모른다.<br>
선택 정렬을 사용해도 확인한 수만 알 수 있기 때문에 같은 코드를 계속 반복하게 된다.<br>
그러므로 최선의 경우(이미 정렬이 되어있는 경우)에도 소요시간이 똑같다.<br>
<b>하한은 Ω(n^2)가 된다.</b>

<br>
<br>

# 재귀

<b>재귀 함수는 자기 자신을 호출한다.

재귀적 정의는 눈에 보이는 혹은 가상의 물체의 구조를
그 물체 자체를 이용해서 설명하는 것을 말한다.</b>

```
#
##
###
####
```

이러한 피라미드를 출력해보자.

<br>

### 높이를 입력받아 중첩루프를 통해 피라미드 출력

```c
#include <cs50.h>
#include <stdio.h>
void draw(int h);
int main(void)
{
    // 사용자로부터 피라미드의 높이를 입력 받아 저장
    int height = get_int("Height: ");
    // 피라미드 그리기
    draw(height);
}
void draw(int h)
{
    // 높이가 h인 피라미드 그리기
    for (int i = 1; i <= h; i++){
        for (int j = 1; j <= i; j++){
            printf("#");
        }
        printf("\n");
    }
}
```

<br>

### 높이를 입력받고 재귀함수를 이용해 피라미드 출력

```c
#include <cs50.h>
#include <stdio.h>
void draw(int h);
int main(void)
{
    int height = get_int("Height: ");
    draw(height);
}
void draw(int h)
{
    // 높이가 0이라면 (그릴 필요가 없다면)
    if (h == 0)
    {
        return;
    }
    // 재귀 호출: 높이가 h-1인 피라미드 그리기
    draw(h - 1);
    // 피라미드에서 폭이 h인 한 층 그리기
    for (int i = 0; i < h; i++)
    {
        printf("#");
    }
    printf("\n");
}
```

- 재귀적으로 스스로를 호출하면서 기존 문제보다 더 작은 크기의 문제를 풀어간다.
- if문이 무한반복을 막아준다.
- 출력을 하기 전에 draw함수를 호출하고, 그 후에 h만큼의 #을 출력한다.
- 재귀함수가 호출되면 높이가 0이 될때까지 호출된다.
- 우선은 함수가 초기에 주어진 입력보다 더 작은 입력을 가지고 계속해서 자신을 호출한다는 것만 이해하자.

<br>
<br>

# 병합정렬

<b>병합정렬은 </b>버블 정렬이나 선택 정렬보다 뛰어난 알고리즘으로 알려진다.

> 병합 정렬은 원소가 한 개가 될 때까지 계속해서 반으로 나누다가 다시 합쳐나가며 정렬을 하는 방식이다.
> <br>

### 병합정렬의 의사코드

```
만약 받은 입력에 아이템(받은 입력의 배열 항목)이 하나라면 그냥 반환한다. - 이미 정렬된 상태
  그렇지 않다면 왼쪽의 절반을 정렬한다.
  나머지 오른쪽 절반을 정렬한다.
  하나의 배열로 합친다.
```

- 배열의 아이템이 한개가 아니라면 왼쪽 정렬, 오른쪽 정렬을 한 후 합치는 것을 반복한다.
- <b>병합이란 두 배열 중에서 가장 작은 값을 꺼내 다른 배열의 가장 작은 값 다음에 두는 과정을 말한다.</b>

<br>

### 병합정렬 방법

다음의 숫자배열을 오름차순으로 정렬해보자.

```
7 4 5 2 6 3 8 1
```

- 숫자를 반으로 나눈다

```
7 4 5 2 | 6 3 8 1
```

- 왼쪽 절반을 더 반으로 나눈다.

```
7 4 | 5 2 | 6 3 8 1
```

- 아이템이 한개가 아니므로 더 나눌 수 있다.

```
7 | 4 | 5 | 2 | 6 3 8 1
```

- 숫자를 병합한다.
- 이때 작은 숫자가 먼저오게 한다.

```
4 7 | 2 5 | 6 3 8 1
```

- 왼쪽과 오른쪽으로 나누어진 숫자를 앞에서부터 비교한다.
- 4와 2를 비교해서 2를 가져오고, 4와 5을 비교해서 4를 가져오는 방식이다.

```
2 4 5 7 | 6 3 8 1
```

- 나머지 오른쪽 숫자들도 같은 방법으로 정렬한다.

```
2 4 5 7 | 1 3 6 8
```

- 왼쪽 부분의 숫자와 오른쪽 부분의 숫자를 비교한다.
- 왼쪽부분의 2부터 오른쪽 부분의 숫자와 비교해서 더 작은 숫자를 가져온다.

```
1 2 3 4 5 6 7 8
```

이것은 곧 다음 과정과 같다.

1. 크기 8의 배열을 쪼개서 크기 1의 배열 8개를 만든다.
2. 크기가 2인 배열 4개로 만든다.
3. 크기가 4인 배열 2개로 만든다.
4. 크기가 8인 하나의 배열로 합친다.

아래에서 위로 올라가는데 가장 아래 배열이 하나 있고, 그것을 계속해서 절반으로 나누는 것과 같다.

<br>

### 병합 정렬의 실행시간

무언가를 계속해서 절반으로 나눈다면 <b>로그 함수</b>로 표현할 수 있다.

주어진 배열을 나눌 수 있는 횟수는 log n번이다.<br>
쪼개는 과정이 한 번 있을 때마다 합치는 과정이 있다.<br>
병합을 할때마다 쪼개진 아이템을 더하기 때문에 모든 n개의 항목을 확인한다.<br>

n개의 숫자를 다시 합치기 위해 log(n)번을 반복하기 때문에
n X log n이다.

따라서 병합 정렬의 Big-O는 <b>O(n log n)</b>이다.<br>

항상 왼쪽 절반 정렬, 오른쪽 절반 정렬 그리고 마지막으로 병합하는 단계를 거치기 때문에 병합정렬의 Big Ω도 <b>Ω(n log n)이다.</b>

<br>

병합 정렬은 버블 정렬이나, 선택 정렬에 비해 최악의 경우
빠른 속도를 보인다.<br>
하지만 맹목적으로 같은 방법을 반복하기 때문에, 최선의 경우 불필요한 시간을 낭비하고,<br> <u>정렬된 자료일 경우</u> 버블 정렬보다 속도가 느리다.<br>

또한 병합을 하는 과정에서 비교적 많은 메모리를 필요로 하고, 재귀적이기 때문에 [stack overflow](https://github.com/leejaypower/TIL/blob/main/CS50/메모리.md#오버플로우,-입력받는-함수)가 발생할 수 있다.

<br>
<hr>
<a href="https://www.boostcourse.org/cs112">모두를 위한 컴퓨터과학(CS50 2019)</a> - 알고리즘으로 공부한 내용입니다.
