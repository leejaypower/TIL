# 버블정렬

배열을 검색할 때, 정렬되지 않은 경우 선형검색처럼 시간이 더 오래걸리고 비효율적인 알고리즘을 사용해야 한다.

상황에 따라 배열에 대해 여러번 탐색을 해야하는 경우라면 먼저 <b>정렬</b>해두는 것이 효율적이다.

<br>

정렬 알고리즘 중 <b>버블정렬</b>이 있다.<br>
새로운 거품이 떠오르듯 왼쪽에서 오른쪽으로 이동하는 방식이라 버블이라는 이름이 붙었다.

> 버블 정렬은 <b>두 개의 인접한 자료 값을 비교하면서 위치를 교환하는 방식</b>으로 정렬하는 방법을 말한다.<br>
> 버블 정렬은 단 두 개의 요소만 정렬해주는 좁은 범위의 정렬에 집중한다.<br>
> 이 접근법은 간단하지만 단 하나의 요소를 정렬하기 위해 <b>너무 많이 교환하는 낭비</b>가 발생할 수도 있다.

```
(6 3) 8 5 2 7 4 1 - 교환
3 (6 8) 5 2 7 4 1 - 그대로 둠
3 6 (8 5) 2 7 4 1 - 교환
3 6 5 (8 2) 7 4 1 - 교환
...
3 6 5 2 8 4 1 7
...
오름차순이 될 때까지 반복
...
1 2 4 3 5 6 7 8
```

<br>

### 버블 정렬의 의사코드

```
n-1번 반복한다.(n명이 있고 서로를 비교한다면 최대 n-1번을 비교할 수 있다.)
  i가 0부터 n-2까지 (여기서 i는 배열의 인덱스) 반복한다.
    i가 0부터 시작할 때, i번째 사람과 i+1번째 사람의 순서가 잘못됐다면 자리를 바꾼다.
```

<br>

### 버블 정렬의 Big-O 표기

```
(n-1) X (n-1)
n² - 1n - 1n + 1
n² - 2n + 1
O(n²)
```

- 바깥 반복문과 안쪽 반복문이 n-1번 반복된다.
- 지수가 가장 큰 n²의 영향력이 가장 크다.
- n이 커질수록 n²가 미치는 영향은 더 커진다.
- 따라서 버블 정렬의 Big-O 표기는 O(n²)이다.
- <b>버블 정렬은 선형 탐색이나 이진 탐색보다 더 시간이 많이 든다.</b>

<small> <i> cs50 강의에서는 비교횟수가 (n-1)(n-1)라고 했지만 버블정렬 공식을 찾아보니 n(n-1)/2 이다. cs50에서 이렇게 설명한 이유가 뭘까..? </i> </small>

<br>

### 버블 정렬의 Big Ω 표기

이미 정렬 되어있는 상태에서도, <br>
버블 정렬은 맹목적으로 여전히 같은 횟수를 반복하게 된다.<br>
따라서 버블 정렬의 하한선도 <b>n²</b>가 된다.

<br>

### 실행시간의 단축

의사코드를 교환이 없을때까지만 반복하도록 바꾸면 이미 정렬이 되어있는 경우 실행 시간을 단축할 수 있다.

```
교환이 일어나지 않을때까지만 반복한다.
  i가 0부터 n-2까지 (여기서 i는 배열의 인덱스) 반복한다.
    i가 0부터 시작할 때, i번째 사람과 i+1번째 사람의 순서가 잘못됐다면 자리를 바꾼다.
```

이 경우 n-1번 반복하므로, <b>버블 정렬의 하한은 Ω(n)이 된다.</b><br>
따라서 버블 정렬은 상황에 따라서 선택 정렬보다 더 빠른 방법이 될 수 있다.

<br>
<hr>
<a href="https://www.boostcourse.org/cs112">모두를 위한 컴퓨터과학(CS50 2019)</a> - 버블정렬로 공부한 내용입니다.
