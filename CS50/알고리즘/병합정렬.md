# 병합정렬

<b>병합정렬은 </b>버블 정렬이나 선택 정렬보다 뛰어난 알고리즘으로 알려진다.

> 병합 정렬은 원소가 한 개가 될 때까지 계속해서 반으로 나누다가 다시 합쳐나가며 정렬을 하는 방식이다.

<br>

### 병합정렬의 의사코드

```
만약 받은 입력에 아이템(받은 입력의 배열 항목)이 하나라면 그냥 반환한다. - 이미 정렬된 상태
  그렇지 않다면 왼쪽의 절반을 정렬한다.
  나머지 오른쪽 절반을 정렬한다.
  하나의 배열로 합친다.
```

- 배열의 아이템이 한개가 아니라면 왼쪽 정렬, 오른쪽 정렬을 한 후 합치는 것을 반복한다.
- <b>병합이란 두 배열 중에서 가장 작은 값을 꺼내 다른 배열의 가장 작은 값 다음에 두는 과정을 말한다.</b>

<br>

### 병합정렬 방법

다음의 숫자배열을 오름차순으로 정렬해보자.

```
7 4 5 2 6 3 8 1
```

- 숫자를 반으로 나눈다

```
7 4 5 2 | 6 3 8 1
```

- 왼쪽 절반을 더 반으로 나눈다.

```
7 4 | 5 2 | 6 3 8 1
```

- 아이템이 한개가 아니므로 더 나눌 수 있다.

```
7 | 4 | 5 | 2 | 6 3 8 1
```

- 숫자를 병합한다.
- 이때 작은 숫자가 먼저오게 한다.

```
4 7 | 2 5 | 6 3 8 1
```

- 왼쪽과 오른쪽으로 나누어진 숫자를 앞에서부터 비교한다.
- 4와 2를 비교해서 2를 가져오고, 4와 5을 비교해서 4를 가져오는 방식이다.

```
2 4 5 7 | 6 3 8 1
```

- 나머지 오른쪽 숫자들도 같은 방법으로 정렬한다.

```
2 4 5 7 | 1 3 6 8
```

- 왼쪽 부분의 숫자와 오른쪽 부분의 숫자를 비교한다.
- 왼쪽부분의 2부터 오른쪽 부분의 숫자와 비교해서 더 작은 숫자를 가져온다.

```
1 2 3 4 5 6 7 8
```

이것은 곧 다음 과정과 같다.

1. 크기 8의 배열을 쪼개서 크기 1의 배열 8개를 만든다.
2. 크기가 2인 배열 4개로 만든다.
3. 크기가 4인 배열 2개로 만든다.
4. 크기가 8인 하나의 배열로 합친다.

아래에서 위로 올라가는데 가장 아래 배열이 하나 있고, 그것을 계속해서 절반으로 나누는 것과 같다.

<br>

### 병합 정렬의 실행시간

무언가를 계속해서 절반으로 나눈다면 <b>로그 함수</b>로 표현할 수 있다.

주어진 배열을 나눌 수 있는 횟수는 log n번이다.<br>
쪼개는 과정이 한 번 있을 때마다 합치는 과정이 있다.<br>
병합을 할때마다 쪼개진 아이템을 더하기 때문에 모든 n개의 항목을 확인한다.<br>

n개의 숫자를 다시 합치기 위해 log(n)번을 반복하기 때문에
n X log n이다.

따라서 병합 정렬의 Big-O는 <b>O(n log n)</b>이다.<br>

항상 왼쪽 절반 정렬, 오른쪽 절반 정렬 그리고 마지막으로 병합하는 단계를 거치기 때문에 병합정렬의 Big Ω도 <b>Ω(n log n)이다.</b>

<br>

병합 정렬은 버블 정렬이나, 선택 정렬에 비해 최악의 경우
빠른 속도를 보인다.<br>
하지만 맹목적으로 같은 방법을 반복하기 때문에, 최선의 경우 불필요한 시간을 낭비하고,<br> <u>정렬된 자료일 경우</u> 버블 정렬보다 속도가 느리다.<br>

또한 병합을 하는 과정에서 비교적 많은 메모리를 필요로 하고, 재귀적이기 때문에 stack overflow가 발생할 수 있다.

<br>
<hr>
<a href="https://www.boostcourse.org/cs112">모두를 위한 컴퓨터과학(CS50 2019)</a> - 병합정렬로 공부한 내용입니다.
