# 배열 목차

1. [컴파일링](#컴파일링)
2. [디버깅, 코드의 디자인](#디버깅,-코드의-디자인)
3. [배열](#배열)
4. [문자열과 배열](#문자열과-배열)
5. [명령행 인자](#명령행-인자)

<br>
<br>

# 컴파일링

stdio.h는 헤더파일로, C언어로 작성되어 있으며 파일명이 .h로 끝난다.

이 파일에는 printf 함수의 프로토타입이 있어서, Clang 컴파일러가 프로그램을 컴파일할 때 printf가 무엇인지 알려주는 역할을 한다.

<br>

### 코드를 컴파일하고 프로그램을 실행하는 과정

```
clang -hello.c
./a.out
```

혹은

```
clang -o hello hello.c
./hello
```

<br>

cs50.h 라이브러리를 사용한 프로그램을 컴파일 할 때는 -lcs50을 붙여줘야 했다.

```
clang -o hello hello.c -lcs50
./hello
```

이는 clang에게 cs50 라이브러리에 있는 모든 0과 1들을 여기에 연결(link)하라는 의미이다.

> 컴파일링은 우리가 해온 것들을 사실 우리가 지금까지 해온 것들을 아주 간단하게 표현한 말이다.

<br>

make나 clang을 사용해서 프로그램을 실행할 때
이와 같은 4단계를 거친다.

### 1. preprocessing(전처리)

```c
#include <cs50.h>
#include <stdio.h>
```

> #으로 시작되는 C소스 코드는 전처리기에게 실질적인 컴파일이 이루어지기 전에 무언가를 실행하라고 알려준다.

- 이 두줄은 해당 파일의 실제 코드로 대체 된다.
- clang이 cs50.h파일에 직접 들어가 해당되는 코드를 가져와서 hello.c라는 파일에 붙여넣는 것이다.

  <br>

### 2. compiling(컴파일)

- 컴파일은 소스코드를 머신코드로 바꾸는 단계를 말하는데, 더 구체적인 단계를 뜻하기도 한다.
- 프로그램이 컴파일 될 때 전처리 과정을 거치고 <b>어셈블리 코드</b>로 바뀐다.
- 컴퓨터의 뇌인 CPU가 실제로 이해할 수 있는 언어에 가까워진다.

<br>

### 3. assembling(어셈블)

- clang이 어셈블리 코드를 0과 1로 이루어진 머신 코드로 바꾼다.

> 소스코드에서 머신코드로 컴파일 되어야 할 파일이 딱 한개라면, 컴파일 작업은 여기서 끝이 난다.

<br>

### 4. linking(링크)

> 프로그램이 여러 개의 파일로 이루어져 있는 경우 링크라는 컴파일의 마지막 단계가 필요하다.

- 위의 세 단계를 거친 여러개의 머신코드 파일을 하나의 큰 머신코드 파일로 합친다.

<br>

이 과정들이 끝나고 나면 최종적으로 실행 가능한 파일이 완성된다.

<br>
<br>

# 디버깅, 코드의 디자인

## 디버깅

> 버그는 의도하지 않은 프로그램 내 실수를 뜻한다.<br> <b>디버깅</b>은 코드에 있는 버그를 식별하고 고치는 과정이다. 프로그래머는 디버거라고 불리는 프로그램을 사용하여 디버깅을 하게 된다.
> <br>

### Break point(중지점)

break point는 수많은 IDE(Intergrated Development Environment: 통합 개발 환경)들이 제공하는 기능이다.

컴퓨터에게 프로그램을 실행할 때 평소처럼 실행하지 않고,<br> 지정된 포인트에서 멈춘뒤 사용자가 한 단계씩 진행할 수 있도록 한다.<br>
문제를 시각적으로 확인할 수 있다.

<br>

## 코드의 디자인

> 회사에서 일을 하거나 소프트웨어를 작성할 때 코드작성만큼이나 중요한 것이<br>바로 코드가 정확한지를 확인하는 <b>테스트</b>를 만드는 것이다.
> 프로그램에 여러 사람들이 협업해서 새로운 기능을 추가할 때<br>
> 프로그램이 고장나지 않도록 작동 여부를 계속해서 확인해줘야 한다.

코드 작성 시에는 자신과 다른 사람들이 읽기 쉽도록,<br>
그리고 무엇보다 <b>유지보수</b>하기 쉽도록 해야 한다.

많은 회사들은 사내에서 코드를 작성할 때 특정한 스타일 가이드를 따르도록 한다.<br>
여러 사람들이 코드를 작성할 때에 발생하는 오해를 없애고,<br>코드를 이해하는데 드는 비용을 최소화하기 때문이다.

<br>
<br>

# 배열

```c
#include <stdio.h>
int main(void){
  char c1 = 'H';
  char c2 = 'i';
  char c3 = '!';
  printf("%c $c $c\n", c1,c2,c3);
}
```

- C에서 char를 입력할 때에는 작은 따옴표(')가 필요하다.(string은 쌍따옴표를 사용했다.)

```
H i !
```

<br>

ASCII코드를 통해 문자를 숫자로 변환한 값을 보고 싶다면 변수 앞에 (int)를 적으면 된다.

```c
printf("%i %i %i\n",(int)c1, (int)c2, (int)c3);
```

- 이를 <b>형변환</b>이라고 한다.
- 하나의 자료형을 다른 종류로 바꾸는 행위를 뜻한다.

```
72 73 33
```

<br>

|    H     |    i     |    !     |
| :------: | :------: | :------: |
|    72    |    73    |    33    |
| 01001000 | 01001001 | 00100001 |
|    c1    |    c2    |    c3    |

- c1, c2, c3 3개의 변수를 가진 -프로그램이 있다면 컴퓨터가 할일은 H와 i, !를 메모리 한 칸에 각자 넣는 것이다.<br>
- 그리고 각 칸에 해당하는 변수명을 저장한다.
- 메모리 안에 실제로 저장된 형태는 2진법이다.

<br>

### 예제

세 개의 점수를 저장하고 출력하는 프로그램

```c
#include <cs50.h>
#include <stdio.h>
int main(void)
{
    // Scores
    int score1 = 72;
    int score2 = 73;
    int score3 = 33;
    // Print average
    printf("Average: %i\n", (score1 + score2 + score3) / 3);
}
```

- 이건 좋은 디자인의 프로그램이 아니다.
- 점수의 개수가 <b>고정적</b>이므로 더 많은 점수가 필요할 경우 지원되지 않고, 많은 수정이 필요하다.

<br>

C에서는 <u>여러 개의 값을 가진 하나의 변수를 만들고 싶을 때</u> &nbsp;<b>배열</b>을 사용한다.

배열은 값들의 리스트로, 모두 같은 자료형의 값들이 같은 이름의 변수에 저장되어 있다.

```c
#include <cs50.h>
#include <stdio.h>
int main(void)
{
    int scores[3];
    // 3개의 값을 하나의 변수에 저장하기 위한 공간
    scores[0] = 72;
    scores[1] = 73;
    scores[2] = 33;
    printf("Average: %i\n", (scores[0] + scores[1] + scores[2]) / 3);
}
```

- 여전히 배열의 인덱스마다 점수를 지정해주어야 한다.(하드코딩)
- 같은 값을 반복하고 있어서(scores[3]과 printf의 3) 실수가 유발될 수 있다.

```c
#include <cs50.h>
#include <stdio.h>
const int N = 3;
/*
const는 constant 상수이다.
관습에 따라 변수 이름을 대문자로 적는다.
*/
int main(void)
{
    int scores[N];
    scores[0] = 72;
    scores[1] = 73;
    scores[2] = 33;
    printf("Average: %i\n", (scores[0] + scores[1] + scores[2]) / N);
}
```

- const로 해당 변수를 상수로 지정하면 clang 컴파일러는 실수로 값을 바꾸지 않도록 해준다.
- n을 어디에 사용하든 언제나 같은 값을 가진다.
- 이를 <b>전역 변수</b>라고 한다. 함수바깥에서 선언한다.
- 전역 변수의 선언을 통해 점수의 개수에 따라 수정해야 하는 코드가 줄어들었다.

<br>

프로그램을 더 개선해보자.

```c
#include <cs50.h>
#include <stdio.h>
float average(int length, int array[]);
// 함수의 프로토타입
int main(void)
{
    int n = get_int("Number of scores : ");
    // 점수가 들어갈 배열
    int scores[n];
    for (int i = 0; i < n; i++){
      scores[i] = get_int("Score %i: ", i + 1);
    }
    printf("Average: %.1f\n", average(n, scores));
    // 평균은 소수점 뒤 한자리만 반올림해서 보여준다.
}
float average(int length, int array[]){
  /*
  평균을 내기 위해 점수가 들어가는 배열의 길이와 그 배열 자체를 받는다.
  자바나 파이썬과 다르게 C의 배열은 스스로의 길이를 기억하지 않기 때문에 배열의 길이를 넣어줘야 한다.
  */
  int sum = 0;
  for(int i = 0; i < length; i++){
    sum += array[i];
    // sum = sum + array[i];
  }
  return (float) sum / (float) length;
}
```

- 동적으로 점수의 개수와 값을 받아오기 위해 cs50의 get_int 함수를 사용한다.

- for문을 사용해서 받아온 점수 개수만큼 반복해서 사용자에게 점수값을 받아온다.

- 평균을 계산하는 함수를 만든다.

- 평균은 소수점이 될 수도 있으니 자료형은 float를 쓴다.

- for문을 사용해서 점수 개수만큼 반복해서 점수들을 더하고, 더한 것을 배열의 길이로 나눈다.

- 하지만 배열의 길이도 정수이고, 점수 값도 정수이기 때문에 나눈 값의 소수점 뒤가 버려지게 된다.

- 이를 보완하기 위해 형변환을 사용한다.

<br>
<br>

# 문자열과 배열

배열 내의 원소의 순서는 바이트 수와 무관하다.<br>
int가 4바이트를 차지한다고 해서 0,4,8번째로 셀 필요가 없다는 뜻이다.<br>
여전히 0,1,2번째로 이어진다.<br>

컴퓨터가 각 값의 자료형에 따라 알아서 필요한 저장공간을 계산한다.<br>

string과 char는 근본적인 관계가 있다.<br>
string은 char의 배열이다.<br>
여러개의 문자들을 저장하는 것이 각 변수마다 하나의 문자를 저장하는 것보다 훨씬 유용하다.

```
string s = "Hi!";
```

|  H   |  i   |  !   |  \0  |
| :--: | :--: | :--: | :--: |
| s[0] | s[1] | s[2] | s[3] |

- string은 문자열의 길이만큼 저장크기가 필요하다.<br>
- C에서 변수의 이름은 시작점에 대한 정보를 알려준다.<br>
- 문자열이 끝나는 것을 알려줄 문자는 <b>널(null)문자, 혹은 널 종단 문자</b>라고 한다.<br>
- \0으로 나타낸다.<br>
- 이는 8개의 비트가 모두 0인 상태를 나타낸다.

<br>

### 여러 문자열이 동시에 선언된 경우

```c
string names[4];
names[0] = "EMMA";
names[1] = "RODRIGO";
names[2] = "BRIAN";
names[3] = "DAVID";
printf("%s\n", names[0]);
printf("%c%c%c%c\n", names[0][0], names[0][1], names[0][2], names[0][3]);
```

- names[0][1]과 같이 2차원 배열을 통해 접근할 수 있다.
- 이렇게 문자열을 출력하는 것은 매우 비효율적이다.
- 하지만 이것은 결국 문자열을 출력하는 것, 즉 C의 printf와 같다.
- printf는 일종의 루프를 만들고 첫번쨰 글자부터 반복해서 널문자인지 확인한다.

<br>

### 문자열의 길이 및 탐색

사용자로부터 문자열을 입력받아 한 글자씩 출력하는 프로그램 예제

```c
#include <cs50.h>
#include <stdio.h>
#include <string.h>
int main(void)
{
    string s = get_string("Input: ");
    printf("Output:\n");
    for (int i = 0, n = strlen(s); i < n; i++)
     // for (int i = 0, i < strlen(s); i++)
     // for(int i = 0; s[i] != '\0'; i++)
    {
        printf("%c\n", s[i]);
    }
}
```

- string.h의 strlen()함수는 문자열의 길이를 반환한다.
- 문자열의 길이는 변하지 않으므로 변수로 만들어 저장할 수 있다.

<br>
<br>

# 명령행 인자

C언어의 <b>main 함수</b>를 뜯어보자.

```c
#include <stdio.h>
int main(int argc, string argv[]){
}
```

- main함수가 두개의 인자를 받는데, 하나는 int이고 하나는 string의 배열이다.
- <b>argc</b>는 인자 개수를 뜻한다. (argument count)

  > argc는 main 함수가 받게 될 입력의 개수이다.

- <b>argv</b>는 관습적인 표현으로 인자벡터를 뜻한다. (argument vector) 인자들의 배열이라는 뜻이다.

  > argv[]는 입력이 포함되어 있는 배열이다.
  > <br>

```c
#include <cs50.h>
#include <stdio.h>
int main(int argc, string argv[])
{
    if (argc == 2)
    // 사용자가 프롬프트에 단어 2개를 입력했다면
    {
        printf("hello, %s\n", argv[1]);
    }
    else
    {
        printf("hello, world\n");
    }
}
```

- 사용자에게 입력을 받을 때 get_string함수 사용 대신 <b>명령 프롬프트</b>를 사용할 수 있다.
- clang과 같은 기능을 구현한다.

<br>

파일을 컴파일하고 실행해보자.

```
./argv
hello, world
```

```
./argv David
hello, David
```

- C로 작성된 프로그램을 실행할 때, 프로그램 이름 뒤에 단어를 입력하면 그 단어들은 argv라는 배열에 들어간다.
- argc에는 단어의 개수가 저장된다.
- argv[0]에는 기본적으로 프로그램의 이름이 저장된다.
- argv[1]에는 뒤에 입력한 David라는 값이 저장된다.
- clang이나 make 등은 이름 뒤에 단어 입력을 받는것이 이런 형태로 구현된 것이라 이해하면 된다.

<br>

### main 함수의 반환값

- C의 main함수는 기본적으로 반환값을 가진다.
- main은 0을 반환한다.
- 0은 보통 문제 없음을 뜻한다.
- main함수는 0이 아닌 값을 반환할 수도 있다.
- 문제가 생기면 사람들이 임의로 정해놓은 에러코드가 반환되게 된다.

<br>
<hr>
<a href="https://www.boostcourse.org/cs112">모두를 위한 컴퓨터과학(CS50 2019)</a> - 명령행인자로 공부한 내용입니다.
