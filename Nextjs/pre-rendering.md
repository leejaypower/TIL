## Next.js는 CSR 단점을 효율적으로 해결하는 기술
- CSR은 초기 로딩 시 렌더링이 느림 
    1. 클라이언트에서 초기 접속 요청 -> 서버는 빈 껍데기 HTML을 응답
    2. 일단 빈 화면 렌더링 (즉 아무것도 안나옴)
    3. 자바스크립트 코드를 묶어서, 즉 번들링 해서 하나의 파일로 만들어서 보내줌 (이 서비스에서 접근 가능한 모든 코드가 존재할 수도 있고 아닐 수도 있음... 요즘엔 다 번들러가 코드 스플리팅을 해주기 떄문에)
    4. 브라우저에서 자바스크립트 코드를 다운받고, **자바스크립트 코드를 실행해서 화면을 렌더링함**
    5. (이 때 CSR은 추가 네트워크 요청이 필요할 수도 있으며, 브라우저는 싱글 스레드이기 때문에 JS를 다운로드 실행하는 동안 브라우저가 멈추는 현상이 발생할 수도 있음)
    6.  **HTML을 거의 비워둔 채로 JS를 실행해 화면을 구성하기 때문에 사용자가 실제로 화면을 볼 수 있기까지는 시간이 걸림**
    7. 즉 FCP가 느림.

### `FCP (First Contentful Paint)`
- 요청 시작 시점으로부터 첫 번째 콘텐츠가 렌더링되는 시간
- 느릴 수록 사용자 이탈률이 증가함

## Next.js의 사전 렌더링
- 브라우저의 요청에 사전에 렌더링이 완료된 HTML을 응답하는 렌더링 방식
- 자바스크립트 코드를 미리 HTML로 변환해둔 다음에 (페이지로 렌더링해둔 다음에) 요청에 따라 해당 HTML을 응답함
- **서버에서 JS 렌더링(HTML 변환)을 수행함**
- (웹 서버는 일반적으로 멀티 스레드 환경에서 실행되니 JS 실행 부담이 줄어들 수 있다.)
- 서버에서 렌더링한 HTML을 처음 받게 되면 인터렉션은 불가능함 (그저 HTML이기 때문)
- `**Hydration (수화)**` 
    - HTML과 자바스크립트를 연결해서 인터렉션이 가능한 페이지로 만드는 과정

## 페이지 이동 요청은?
- 페이지 이동 요청은 브라우저에서 이루어짐
- CSR과 똑같은 방식으로 처리
    - 페이지 이동 요청 -> JS 실행(컴포넌트 교체) -> 페이지 교체
- 즉, 첫 페이지 요청 시에는 SSR(서버 사이드 렌더링)으로 HTML을 받아오고, 이후 페이지 이동 시에는 CSR 방식으로 처리하는 구조(후속으로 번들링된 JS 파일을 서버로부터 받는다.)

### 이를 통해 SEO 문제를 해결하면서도, CSR의 부드러운 UX 유지 가능
- 검색 엔진 크롤러(봇)는 **첫 페이지 로드**에서 받은 SSR된 HTML을 분석하기 때문

## 궁금 포인트
- 현대 번들러에서는 기본적으로 코드 스플리팅을 통해 번들링을 진행하기 때문에, 초기 렌더링 시에도 빠르게 렌더링이 가능할텐데?
    - 코드 스플리팅을 통해 초기 로딩 속도 문제는 개선할 수 있지만 모든 단점이 해결되는건 아니다.
    - SSR과 비교하면 첫 번째 페인트 시간은 여전히 늦게 표시될 가능성이 있다.
    - SEO 최적화 문제
    - 네트워크 의존성이 좀 더 높음? 
        - JS가 다운로드 안된다면 아예 화면이 안뜰 수도 있다. 
        - 하지만 Hydration 방식이라면 JS가 실행되기 전에도 기본적인 콘텐츠는 볼 수 있다.