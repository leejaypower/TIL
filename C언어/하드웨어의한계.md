# 하드웨어의 한계

모든 컴퓨터에는 <b>메모리 혹은 RAM</b>이라고 하는 것이 들어있다.<br>
RAM은 모든 프로그램이 실행 중 저장되는 곳이다.<br>
그리고 모든 파일들이 열려있는 동안 저장되는 곳이다.<br>
컴퓨터가 여러 일들을 한 번에 할 때, 기억하기 위해 사용되는 것이다.<br>
하지만 어디까지나 하드웨어이기 때문에 그 성능, 즉 메모리의 용량은 유한하다.<br>

컴퓨터가 할 수 있는 일에는 근본적인 한계가 존재한다는 말이다.

<br>

### 사용자에게 몇 개의 실수값을 받아오는 프로그램

```C
#include <cs50.h>
#include <stdio.h>

int main(void){
float x = get_float("x: ");
float y = get_float("y: ");

printf("x / y = %.50f\n", x / y);
}

```

- x와 y값을 받아서 나눈다.
- 나눈값은 소수점 뒤 50자리까지 보도록 한다.

```terminal
x:1
y:10
x / y = 0.10000000149011611938476562500000000000000000000000
```

### 왜 이런 결과가 나올까?

- <u>메모리의 저장 공간이 유한하기 때문에</u> 컴퓨터는 특정 지점에서 한계에 부딪힌다.
- float는 32비트를 사용하고, double은 64비트를 사용한다.
- 소수점 뒤 이보다 많은 숫자는 저장할 수 없다.

컴퓨터는 완벽하지 않다.

- 컴퓨터는 계산할 수 있는 값들 중 1/10에 가장 가까운 값을 저장한다.
- 유한한 정보를 사용해서는 무한한 숫자들을 100% 정확하게 저장할 수 없기 떄문이다.

<br>

## 정수 오버플로우

```c
#include <stdio.h>
#include <unistd.h>

int main(void){
  for(int i=1; ; i *= 2)
  {
    printf("%i\n", i);
    sleep(1);
  }
}
```

- i가 1부터 시작하고 2를 계속해서 곱하여 출력한다.
- for문에 불리언 표현을 적지 않았기에 무한반복된다.
- 곱하는 사이 1초간 쉰다.(sleep 이라는 C언어의 함수를 사용)

<br>

```
...
overflow.c:6:25: runtime error: signed integer overflow: 1073741824 * 2 cannot be represented in type 'int'
-2147483648
0
0
...
```

- 2를 계속 곱하다보면 int가 저장할 수 있는 값을 넘게 된다.
- 에러가 발생하고 0이 출력된다.
- int의 32비트 이상의 숫자는 저장할 수 없다.
- 숫자가 커지면서(10억을 넘기면) 앞으로 넘어갈 1의 자리가 없어진다.
- 결국 앞으로 가져온 1이 사라지면서 실제로 저장된 값은 0만 남는 것이다.

이런 오버플로우 문제가 발생하면 변수를 다시 0으로 리셋해야 한다.<br>

> 따라서 다루고자 하는 데이터 값의 범위를 유의하며 프로그램을 작성하는 것이 중요하다.

<br>
<hr>
<a href="https://www.boostcourse.org/cs112">모두를 위한 컴퓨터과학(CS50 2019)</a> - 하드웨어의 한계로 공부한 내용입니다.
