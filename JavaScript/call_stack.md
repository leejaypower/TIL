# call stack - 호출 스택

```
┌─────────────────────────────┐
│       * Call Stack *        │
│ - 현재 실행 중인 함수들          │
│ - LIFO 구조                  │
│                             │
│ 예: 함수 호출, console.log     │
└─────────────────────────────┘
                │
                ▼
┌─────────────────────────────┐
│        * Event Loop *       │
│ - 스택이 비면 큐에서 작업을       │
│   가져와 실행                  │
└─────────────────────────────┘
        │                 │
        ▼                 ▼
┌─────────────────────────────┐      ┌─────────────────────────────┐
│    * Macro Task Queue *     │      │     * Micro Task Queue *    │
│ - 큰 단위의 비동기 작업들         │      │ - 우선순위 가장 높은 작업들       │
│ - 마이크로 큐 비면 실행          │      │ - 스택 비면 가장 먼저 실행        │
│                             │      │                             │
│ 예:                          │      │ 예:                         │
│  • setTimeout               │      │  • Promise.then             │
│  • setInterval              │      │  • async/await 후속 처리      │
│  • DOM 이벤트(click)          │      │  • queueMicrotask           │
│  • requestAnimationFrame    │      │                             │
└─────────────────────────────┘      └─────────────────────────────┘


```

코드는 위에서부터 아래로 실행된다.
이 때 a 함수를 호출하면 함수의 선언부가 실행되는데, 이 때 콜스택에 a라는 함수가 쌓이게 된다.
만약 a 함수안에서 다른 함수를 호출한다면 a 함수 위로 (다음으로) 스택에 쌓인다.
a 함수 안에서 b, c 등의 함수가 실행된다면 b, c 함수가 종료될 때 하나씩 스택에서 제거된다. 그리고 모든 a 함수 블록 내의 모든 코드가 실행되었을 때 a까지 스택에서 비워진다.


```javascript
const x = 'x';

function c () {
  const y = 'y';
  console.log('c');
}

function a() {
  const x = 'x';
  console.log('a';
  function b() {
      const z = 'z';
      console.log('b');
      c();
  }
  b();
}

a(); // a, b, c
c(); // c;
```

위 코드를 콜스택 흐름으로 정리하자면 아래와 같다!

```
① a() 호출
┌─────────────────────────────┐
│ a()                         │
└─────────────────────────────┘

② a() 내부: console.log('a') 실행
┌─────────────────────────────┐
│ console.log('a')            │
├─────────────────────────────┤
│ a()                         │
└─────────────────────────────┘

③ log 종료 - 제거됨 → b() 호출
┌─────────────────────────────┐
│ b()                         │
├─────────────────────────────┤
│ a()                         │
└─────────────────────────────┘

④ b() 내부: console.log('b')
┌─────────────────────────────┐
│ console.log('b')            │
├─────────────────────────────┤
│ b()                         │
├─────────────────────────────┤
│ a()                         │
└─────────────────────────────┘

⑤ log 종료 - 제거됨 → b() 내부에서 c() 호출
┌─────────────────────────────┐
│ c()                         │
├─────────────────────────────┤
│ b()                         │
├─────────────────────────────┤
│ a()                         │
└─────────────────────────────┘

⑥ c() 내부: console.log('c')
┌─────────────────────────────┐
│ console.log('c')            │
├─────────────────────────────┤
│ c()                         │
├─────────────────────────────┤
│ b()                         │
├─────────────────────────────┤
│ a()                         │
└─────────────────────────────┘

⑦ log 종료 - 제거됨 → c() 종료 → b() 종료 → a() 종료

(스택 비었음)
┌─────────────────────────────┐
│           EMPTY             │
└─────────────────────────────┘


⑧ 독립적인 c() 다시 호출
┌─────────────────────────────┐
│ c()                         │
└─────────────────────────────┘

⑨ console.log('c')
┌─────────────────────────────┐
│ console.log('c')            │
├─────────────────────────────┤
│ c()                         │
└─────────────────────────────┘

⑩ 종료 후 스택 완전 비워짐
┌─────────────────────────────┐
│           EMPTY             │
└─────────────────────────────┘

```

## 부록 - scope chain
함수 내에서 어떤 값에 접근이 가능하고 불가능한가? 
콜스택에서 사용했던 위 코드를 살짝만 수정해보자.

```javascript
const x = 'x';

function c () {
  const y = 'y';
  console.log('c');

  function b() {
    const z = 'z';
    console.log('b');
    c();
  }   
}

function a() {
  const x = 'x';
  console.log('a';

  b(); // ❗️ b is not defined 에러
 }

a(); // a, b, c
c(); // c;
```

호출 스택에서 "호출"을 기준으로 그렸다면 "선언"을 기준으로 생각하면 된다.
- c ⊂ anonymous (전역 global)
- a ⊂ anonymous
  - a는 a 내의 선언된 함수나 global만 값에 접근가능하니까 위처럼 b는 당연히 접근 불가해서 에러가 난다.
- b ⊂ c ⊂ anonymous 
  - 바뀔 수 없는 고정적인 범위(스코프): [lexical scope](https://github.com/leejaypower/play-ground/blob/main/javascript/lexical-closure.js)